/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package org.openapis.openapi;

import static org.openapis.openapi.operations.Operations.AsyncRequestOperation;

import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;
import java.lang.Boolean;
import java.lang.String;
import java.util.concurrent.CompletableFuture;
import org.openapis.openapi.models.components.CreateTopicSubscriptionsRequestDto;
import org.openapis.openapi.models.components.CreateUpdateTopicRequestDto;
import org.openapis.openapi.models.components.UpdateTopicRequestDto;
import org.openapis.openapi.models.operations.TopicsControllerCreateTopicSubscriptionsRequest;
import org.openapis.openapi.models.operations.TopicsControllerDeleteTopicRequest;
import org.openapis.openapi.models.operations.TopicsControllerGetTopicRequest;
import org.openapis.openapi.models.operations.TopicsControllerListTopicsRequest;
import org.openapis.openapi.models.operations.TopicsControllerUpdateTopicRequest;
import org.openapis.openapi.models.operations.TopicsControllerUpsertTopicRequest;
import org.openapis.openapi.models.operations.async.TopicsControllerCreateTopicSubscriptionsRequestBuilder;
import org.openapis.openapi.models.operations.async.TopicsControllerCreateTopicSubscriptionsResponse;
import org.openapis.openapi.models.operations.async.TopicsControllerDeleteTopicRequestBuilder;
import org.openapis.openapi.models.operations.async.TopicsControllerDeleteTopicResponse;
import org.openapis.openapi.models.operations.async.TopicsControllerGetTopicRequestBuilder;
import org.openapis.openapi.models.operations.async.TopicsControllerGetTopicResponse;
import org.openapis.openapi.models.operations.async.TopicsControllerListTopicsRequestBuilder;
import org.openapis.openapi.models.operations.async.TopicsControllerListTopicsResponse;
import org.openapis.openapi.models.operations.async.TopicsControllerUpdateTopicRequestBuilder;
import org.openapis.openapi.models.operations.async.TopicsControllerUpdateTopicResponse;
import org.openapis.openapi.models.operations.async.TopicsControllerUpsertTopicRequestBuilder;
import org.openapis.openapi.models.operations.async.TopicsControllerUpsertTopicResponse;
import org.openapis.openapi.operations.TopicsControllerCreateTopicSubscriptions;
import org.openapis.openapi.operations.TopicsControllerDeleteTopic;
import org.openapis.openapi.operations.TopicsControllerGetTopic;
import org.openapis.openapi.operations.TopicsControllerListTopics;
import org.openapis.openapi.operations.TopicsControllerUpdateTopic;
import org.openapis.openapi.operations.TopicsControllerUpsertTopic;
import org.openapis.openapi.utils.Headers;
import org.openapis.openapi.utils.Options;


public class AsyncTopics {
    private static final Headers _headers = Headers.EMPTY;
    private final SDKConfiguration sdkConfiguration;
    private final AsyncSubscriptions subscriptions;
    private final AsyncTopicsSubscribers subscribers;
    private final Topics syncSDK;

    AsyncTopics(Topics syncSDK, SDKConfiguration sdkConfiguration) {
        this.sdkConfiguration = sdkConfiguration;
        this.subscriptions = new AsyncSubscriptions(syncSDK.subscriptions(), this.sdkConfiguration);
        this.subscribers = new AsyncTopicsSubscribers(syncSDK.subscribers(), this.sdkConfiguration);
        this.syncSDK = syncSDK;
    }

    public final AsyncSubscriptions subscriptions() {
        return subscriptions;
    }

    public final AsyncTopicsSubscribers subscribers() {
        return subscribers;
    }

    /**
     * Switches to the sync SDK.
     * 
     * @return The sync SDK
     */
    public Topics sync() {
        return syncSDK;
    }


    /**
     * List all topics
     * 
     * <p>This api returns a paginated list of topics.
     * Topics can be filtered by **key**, **name**, or **includeCursor** to paginate through the list.
     * Checkout all available filters in the query section.
     * 
     * @return The async call builder
     */
    public TopicsControllerListTopicsRequestBuilder getAll() {
        return new TopicsControllerListTopicsRequestBuilder(sdkConfiguration);
    }

    /**
     * List all topics
     * 
     * <p>This api returns a paginated list of topics.
     * Topics can be filtered by **key**, **name**, or **includeCursor** to paginate through the list.
     * Checkout all available filters in the query section.
     * 
     * @param request The request object containing all the parameters for the API call.
     * @return {@code CompletableFuture<TopicsControllerListTopicsResponse>} - The async response
     */
    public CompletableFuture<TopicsControllerListTopicsResponse> getAll(@Nonnull TopicsControllerListTopicsRequest request) {
        return getAll(request, null);
    }

    /**
     * List all topics
     * 
     * <p>This api returns a paginated list of topics.
     * Topics can be filtered by **key**, **name**, or **includeCursor** to paginate through the list.
     * Checkout all available filters in the query section.
     * 
     * @param request The request object containing all the parameters for the API call.
     * @param options additional options
     * @return {@code CompletableFuture<TopicsControllerListTopicsResponse>} - The async response
     */
    public CompletableFuture<TopicsControllerListTopicsResponse> getAll(@Nonnull TopicsControllerListTopicsRequest request, @Nullable Options options) {
        AsyncRequestOperation<TopicsControllerListTopicsRequest, TopicsControllerListTopicsResponse> operation
              = new TopicsControllerListTopics.Async(
                                    sdkConfiguration, options, sdkConfiguration.retryScheduler(),
                                    _headers);
        return operation.doRequest(request)
            .thenCompose(operation::handleResponse);
    }


    /**
     * Create a topic
     * 
     * <p>Creates a new topic if it does not exist, or updates an existing topic if it already exists. Use
     * ?failIfExists=true to prevent updates.
     * 
     * @return The async call builder
     */
    public TopicsControllerUpsertTopicRequestBuilder create() {
        return new TopicsControllerUpsertTopicRequestBuilder(sdkConfiguration);
    }

    /**
     * Create a topic
     * 
     * <p>Creates a new topic if it does not exist, or updates an existing topic if it already exists. Use
     * ?failIfExists=true to prevent updates.
     * 
     * @param body 
     * @return {@code CompletableFuture<TopicsControllerUpsertTopicResponse>} - The async response
     */
    public CompletableFuture<TopicsControllerUpsertTopicResponse> create(@Nonnull CreateUpdateTopicRequestDto body) {
        return create(
                null, null, body,
                null);
    }

    /**
     * Create a topic
     * 
     * <p>Creates a new topic if it does not exist, or updates an existing topic if it already exists. Use
     * ?failIfExists=true to prevent updates.
     * 
     * @param failIfExists If true, the request will fail if a topic with the same key already exists
     * @param idempotencyKey A header for idempotency purposes
     * @param body 
     * @param options additional options
     * @return {@code CompletableFuture<TopicsControllerUpsertTopicResponse>} - The async response
     */
    public CompletableFuture<TopicsControllerUpsertTopicResponse> create(
            @Nullable Boolean failIfExists, @Nullable String idempotencyKey,
            @Nonnull CreateUpdateTopicRequestDto body, @Nullable Options options) {
        TopicsControllerUpsertTopicRequest request = new TopicsControllerUpsertTopicRequest(failIfExists, idempotencyKey, body);
        AsyncRequestOperation<TopicsControllerUpsertTopicRequest, TopicsControllerUpsertTopicResponse> operation
              = new TopicsControllerUpsertTopic.Async(
                                    sdkConfiguration, options, sdkConfiguration.retryScheduler(),
                                    _headers);
        return operation.doRequest(request)
            .thenCompose(operation::handleResponse);
    }


    /**
     * Retrieve a topic
     * 
     * <p>Retrieve a topic by its unique key identifier **topicKey**
     * 
     * @return The async call builder
     */
    public TopicsControllerGetTopicRequestBuilder getTopic() {
        return new TopicsControllerGetTopicRequestBuilder(sdkConfiguration);
    }

    /**
     * Retrieve a topic
     * 
     * <p>Retrieve a topic by its unique key identifier **topicKey**
     * 
     * @param topicKey The key identifier of the topic
     * @return {@code CompletableFuture<TopicsControllerGetTopicResponse>} - The async response
     */
    public CompletableFuture<TopicsControllerGetTopicResponse> getTopic(@Nonnull String topicKey) {
        return getTopic(topicKey, null, null);
    }

    /**
     * Retrieve a topic
     * 
     * <p>Retrieve a topic by its unique key identifier **topicKey**
     * 
     * @param topicKey The key identifier of the topic
     * @param idempotencyKey A header for idempotency purposes
     * @param options additional options
     * @return {@code CompletableFuture<TopicsControllerGetTopicResponse>} - The async response
     */
    public CompletableFuture<TopicsControllerGetTopicResponse> getTopic(
            @Nonnull String topicKey, @Nullable String idempotencyKey,
            @Nullable Options options) {
        TopicsControllerGetTopicRequest request = new TopicsControllerGetTopicRequest(topicKey, idempotencyKey);
        AsyncRequestOperation<TopicsControllerGetTopicRequest, TopicsControllerGetTopicResponse> operation
              = new TopicsControllerGetTopic.Async(
                                    sdkConfiguration, options, sdkConfiguration.retryScheduler(),
                                    _headers);
        return operation.doRequest(request)
            .thenCompose(operation::handleResponse);
    }


    /**
     * Update a topic
     * 
     * <p>Update a topic name by its unique key identifier **topicKey**
     * 
     * @return The async call builder
     */
    public TopicsControllerUpdateTopicRequestBuilder patch() {
        return new TopicsControllerUpdateTopicRequestBuilder(sdkConfiguration);
    }

    /**
     * Update a topic
     * 
     * <p>Update a topic name by its unique key identifier **topicKey**
     * 
     * @param topicKey The key identifier of the topic
     * @param body 
     * @return {@code CompletableFuture<TopicsControllerUpdateTopicResponse>} - The async response
     */
    public CompletableFuture<TopicsControllerUpdateTopicResponse> patch(@Nonnull String topicKey, @Nonnull UpdateTopicRequestDto body) {
        return patch(
                topicKey, null, body,
                null);
    }

    /**
     * Update a topic
     * 
     * <p>Update a topic name by its unique key identifier **topicKey**
     * 
     * @param topicKey The key identifier of the topic
     * @param idempotencyKey A header for idempotency purposes
     * @param body 
     * @param options additional options
     * @return {@code CompletableFuture<TopicsControllerUpdateTopicResponse>} - The async response
     */
    public CompletableFuture<TopicsControllerUpdateTopicResponse> patch(
            @Nonnull String topicKey, @Nullable String idempotencyKey,
            @Nonnull UpdateTopicRequestDto body, @Nullable Options options) {
        TopicsControllerUpdateTopicRequest request = new TopicsControllerUpdateTopicRequest(topicKey, idempotencyKey, body);
        AsyncRequestOperation<TopicsControllerUpdateTopicRequest, TopicsControllerUpdateTopicResponse> operation
              = new TopicsControllerUpdateTopic.Async(
                                    sdkConfiguration, options, sdkConfiguration.retryScheduler(),
                                    _headers);
        return operation.doRequest(request)
            .thenCompose(operation::handleResponse);
    }


    /**
     * Delete a topic
     * 
     * <p>Delete a topic by its unique key identifier **topicKey**.
     * This action is irreversible and will remove all subscriptions to the topic.
     * 
     * @return The async call builder
     */
    public TopicsControllerDeleteTopicRequestBuilder remove() {
        return new TopicsControllerDeleteTopicRequestBuilder(sdkConfiguration);
    }

    /**
     * Delete a topic
     * 
     * <p>Delete a topic by its unique key identifier **topicKey**.
     * This action is irreversible and will remove all subscriptions to the topic.
     * 
     * @param topicKey The key identifier of the topic
     * @return {@code CompletableFuture<TopicsControllerDeleteTopicResponse>} - The async response
     */
    public CompletableFuture<TopicsControllerDeleteTopicResponse> remove(@Nonnull String topicKey) {
        return remove(topicKey, null, null);
    }

    /**
     * Delete a topic
     * 
     * <p>Delete a topic by its unique key identifier **topicKey**.
     * This action is irreversible and will remove all subscriptions to the topic.
     * 
     * @param topicKey The key identifier of the topic
     * @param idempotencyKey A header for idempotency purposes
     * @param options additional options
     * @return {@code CompletableFuture<TopicsControllerDeleteTopicResponse>} - The async response
     */
    public CompletableFuture<TopicsControllerDeleteTopicResponse> remove(
            @Nonnull String topicKey, @Nullable String idempotencyKey,
            @Nullable Options options) {
        TopicsControllerDeleteTopicRequest request = new TopicsControllerDeleteTopicRequest(topicKey, idempotencyKey);
        AsyncRequestOperation<TopicsControllerDeleteTopicRequest, TopicsControllerDeleteTopicResponse> operation
              = new TopicsControllerDeleteTopic.Async(
                                    sdkConfiguration, options, sdkConfiguration.retryScheduler(),
                                    _headers);
        return operation.doRequest(request)
            .thenCompose(operation::handleResponse);
    }


    /**
     * Create topic subscriptions
     * 
     * <p>This api will create subscription for subscriberIds for a topic.
     * Its like subscribing to a common interest group. if topic does not exist, it will be created.
     * 
     * @return The async call builder
     */
    public TopicsControllerCreateTopicSubscriptionsRequestBuilder createSubscription() {
        return new TopicsControllerCreateTopicSubscriptionsRequestBuilder(sdkConfiguration);
    }

    /**
     * Create topic subscriptions
     * 
     * <p>This api will create subscription for subscriberIds for a topic.
     * Its like subscribing to a common interest group. if topic does not exist, it will be created.
     * 
     * @param topicKey The key identifier of the topic
     * @param body 
     * @return {@code CompletableFuture<TopicsControllerCreateTopicSubscriptionsResponse>} - The async response
     */
    public CompletableFuture<TopicsControllerCreateTopicSubscriptionsResponse> createSubscription(@Nonnull String topicKey, @Nonnull CreateTopicSubscriptionsRequestDto body) {
        return createSubscription(
                topicKey, null, body,
                null);
    }

    /**
     * Create topic subscriptions
     * 
     * <p>This api will create subscription for subscriberIds for a topic.
     * Its like subscribing to a common interest group. if topic does not exist, it will be created.
     * 
     * @param topicKey The key identifier of the topic
     * @param idempotencyKey A header for idempotency purposes
     * @param body 
     * @param options additional options
     * @return {@code CompletableFuture<TopicsControllerCreateTopicSubscriptionsResponse>} - The async response
     */
    public CompletableFuture<TopicsControllerCreateTopicSubscriptionsResponse> createSubscription(
            @Nonnull String topicKey, @Nullable String idempotencyKey,
            @Nonnull CreateTopicSubscriptionsRequestDto body, @Nullable Options options) {
        TopicsControllerCreateTopicSubscriptionsRequest request = new TopicsControllerCreateTopicSubscriptionsRequest(topicKey, idempotencyKey, body);
        AsyncRequestOperation<TopicsControllerCreateTopicSubscriptionsRequest, TopicsControllerCreateTopicSubscriptionsResponse> operation
              = new TopicsControllerCreateTopicSubscriptions.Async(
                                    sdkConfiguration, options, sdkConfiguration.retryScheduler(),
                                    _headers);
        return operation.doRequest(request)
            .thenCompose(operation::handleResponse);
    }

}
