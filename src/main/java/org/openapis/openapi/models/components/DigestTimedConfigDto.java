/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package org.openapis.openapi.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.annotation.Nullable;
import java.lang.Double;
import java.lang.Override;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import org.openapis.openapi.utils.Utils;


public class DigestTimedConfigDto {
    /**
     * Time at which the digest is triggered
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("atTime")
    private String atTime;

    /**
     * Days of the week for the digest
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("weekDays")
    private List<DigestTimedConfigDtoWeekDay> weekDays;

    /**
     * Specific days of the month for the digest
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("monthDays")
    private List<Double> monthDays;

    /**
     * Ordinal position for the digest
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ordinal")
    private OrdinalEnum ordinal;

    /**
     * Value of the ordinal
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ordinalValue")
    private OrdinalValueEnum ordinalValue;

    /**
     * Type of monthly schedule
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("monthlyType")
    private MonthlyTypeEnum monthlyType;

    /**
     * Cron expression for scheduling
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cronExpression")
    private String cronExpression;

    /**
     * Until date for scheduling
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("untilDate")
    private String untilDate;

    @JsonCreator
    public DigestTimedConfigDto(
            @JsonProperty("atTime") @Nullable String atTime,
            @JsonProperty("weekDays") @Nullable List<DigestTimedConfigDtoWeekDay> weekDays,
            @JsonProperty("monthDays") @Nullable List<Double> monthDays,
            @JsonProperty("ordinal") @Nullable OrdinalEnum ordinal,
            @JsonProperty("ordinalValue") @Nullable OrdinalValueEnum ordinalValue,
            @JsonProperty("monthlyType") @Nullable MonthlyTypeEnum monthlyType,
            @JsonProperty("cronExpression") @Nullable String cronExpression,
            @JsonProperty("untilDate") @Nullable String untilDate) {
        this.atTime = atTime;
        this.weekDays = weekDays;
        this.monthDays = monthDays;
        this.ordinal = ordinal;
        this.ordinalValue = ordinalValue;
        this.monthlyType = monthlyType;
        this.cronExpression = cronExpression;
        this.untilDate = untilDate;
    }
    
    public DigestTimedConfigDto() {
        this(null, null, null,
            null, null, null,
            null, null);
    }

    /**
     * Time at which the digest is triggered
     */
    public Optional<String> atTime() {
        return Optional.ofNullable(this.atTime);
    }

    /**
     * Days of the week for the digest
     */
    public Optional<List<DigestTimedConfigDtoWeekDay>> weekDays() {
        return Optional.ofNullable(this.weekDays);
    }

    /**
     * Specific days of the month for the digest
     */
    public Optional<List<Double>> monthDays() {
        return Optional.ofNullable(this.monthDays);
    }

    /**
     * Ordinal position for the digest
     */
    public Optional<OrdinalEnum> ordinal() {
        return Optional.ofNullable(this.ordinal);
    }

    /**
     * Value of the ordinal
     */
    public Optional<OrdinalValueEnum> ordinalValue() {
        return Optional.ofNullable(this.ordinalValue);
    }

    /**
     * Type of monthly schedule
     */
    public Optional<MonthlyTypeEnum> monthlyType() {
        return Optional.ofNullable(this.monthlyType);
    }

    /**
     * Cron expression for scheduling
     */
    public Optional<String> cronExpression() {
        return Optional.ofNullable(this.cronExpression);
    }

    /**
     * Until date for scheduling
     */
    public Optional<String> untilDate() {
        return Optional.ofNullable(this.untilDate);
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Time at which the digest is triggered
     */
    public DigestTimedConfigDto withAtTime(@Nullable String atTime) {
        this.atTime = atTime;
        return this;
    }


    /**
     * Days of the week for the digest
     */
    public DigestTimedConfigDto withWeekDays(@Nullable List<DigestTimedConfigDtoWeekDay> weekDays) {
        this.weekDays = weekDays;
        return this;
    }


    /**
     * Specific days of the month for the digest
     */
    public DigestTimedConfigDto withMonthDays(@Nullable List<Double> monthDays) {
        this.monthDays = monthDays;
        return this;
    }


    /**
     * Ordinal position for the digest
     */
    public DigestTimedConfigDto withOrdinal(@Nullable OrdinalEnum ordinal) {
        this.ordinal = ordinal;
        return this;
    }


    /**
     * Value of the ordinal
     */
    public DigestTimedConfigDto withOrdinalValue(@Nullable OrdinalValueEnum ordinalValue) {
        this.ordinalValue = ordinalValue;
        return this;
    }


    /**
     * Type of monthly schedule
     */
    public DigestTimedConfigDto withMonthlyType(@Nullable MonthlyTypeEnum monthlyType) {
        this.monthlyType = monthlyType;
        return this;
    }


    /**
     * Cron expression for scheduling
     */
    public DigestTimedConfigDto withCronExpression(@Nullable String cronExpression) {
        this.cronExpression = cronExpression;
        return this;
    }


    /**
     * Until date for scheduling
     */
    public DigestTimedConfigDto withUntilDate(@Nullable String untilDate) {
        this.untilDate = untilDate;
        return this;
    }


    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        DigestTimedConfigDto other = (DigestTimedConfigDto) o;
        return 
            Utils.enhancedDeepEquals(this.atTime, other.atTime) &&
            Utils.enhancedDeepEquals(this.weekDays, other.weekDays) &&
            Utils.enhancedDeepEquals(this.monthDays, other.monthDays) &&
            Utils.enhancedDeepEquals(this.ordinal, other.ordinal) &&
            Utils.enhancedDeepEquals(this.ordinalValue, other.ordinalValue) &&
            Utils.enhancedDeepEquals(this.monthlyType, other.monthlyType) &&
            Utils.enhancedDeepEquals(this.cronExpression, other.cronExpression) &&
            Utils.enhancedDeepEquals(this.untilDate, other.untilDate);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            atTime, weekDays, monthDays,
            ordinal, ordinalValue, monthlyType,
            cronExpression, untilDate);
    }
    
    @Override
    public String toString() {
        return Utils.toString(DigestTimedConfigDto.class,
                "atTime", atTime,
                "weekDays", weekDays,
                "monthDays", monthDays,
                "ordinal", ordinal,
                "ordinalValue", ordinalValue,
                "monthlyType", monthlyType,
                "cronExpression", cronExpression,
                "untilDate", untilDate);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private String atTime;

        private List<DigestTimedConfigDtoWeekDay> weekDays;

        private List<Double> monthDays;

        private OrdinalEnum ordinal;

        private OrdinalValueEnum ordinalValue;

        private MonthlyTypeEnum monthlyType;

        private String cronExpression;

        private String untilDate;

        private Builder() {
          // force use of static builder() method
        }

        /**
         * Time at which the digest is triggered
         */
        public Builder atTime(@Nullable String atTime) {
            this.atTime = atTime;
            return this;
        }

        /**
         * Days of the week for the digest
         */
        public Builder weekDays(@Nullable List<DigestTimedConfigDtoWeekDay> weekDays) {
            this.weekDays = weekDays;
            return this;
        }

        /**
         * Specific days of the month for the digest
         */
        public Builder monthDays(@Nullable List<Double> monthDays) {
            this.monthDays = monthDays;
            return this;
        }

        /**
         * Ordinal position for the digest
         */
        public Builder ordinal(@Nullable OrdinalEnum ordinal) {
            this.ordinal = ordinal;
            return this;
        }

        /**
         * Value of the ordinal
         */
        public Builder ordinalValue(@Nullable OrdinalValueEnum ordinalValue) {
            this.ordinalValue = ordinalValue;
            return this;
        }

        /**
         * Type of monthly schedule
         */
        public Builder monthlyType(@Nullable MonthlyTypeEnum monthlyType) {
            this.monthlyType = monthlyType;
            return this;
        }

        /**
         * Cron expression for scheduling
         */
        public Builder cronExpression(@Nullable String cronExpression) {
            this.cronExpression = cronExpression;
            return this;
        }

        /**
         * Until date for scheduling
         */
        public Builder untilDate(@Nullable String untilDate) {
            this.untilDate = untilDate;
            return this;
        }

        public DigestTimedConfigDto build() {
            return new DigestTimedConfigDto(
                atTime, weekDays, monthDays,
                ordinal, ordinalValue, monthlyType,
                cronExpression, untilDate);
        }

    }
}
